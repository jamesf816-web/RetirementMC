# callbacks/simulation_callbacks.py
from dash import Input, Output, State, callback, no_update
import plotly.graph_objects as go
import html
import time
from utils.input_adapter import get_planner_inputs        # We'll create this next
from engine.simulator import RetirementSimulator

def register_simulation_callbacks(app):
    @app.callback(
        Output("balance-paths-graph", "figure"),
        Output("ending-balance-hist", "figure"),
        Output("metrics-table", "children"),
        Output("debug-output", "children"),
        Input("run", "n_clicks"),
        State("nsims", "value"),
        State("base_annual_spending", "value"),
        State("withdrawal_rate", "value"),
        State("portfolio-grid", "rowData"),   # Direct from AG-Grid
        prevent_initial_call=True
    )
    def run_simulation(n_clicks, n_sims, base_spending, withdrawal_rate, portfolio_rows):
        if not n_clicks:
            return no_update

        start_time = time.time()

        try:
            # Build inputs from current UI
            inputs = get_planner_inputs(
                num_simulations=n_sims or 1000,
                base_annual_spending=base_spending or 140000,
                withdrawal_rate=withdrawal_rate or 0.05,
                portfolio_data=portfolio_rows or [],
                # Add more fields later (tax_strategy, etc.)
            )

            sim = RetirementSimulator(inputs)
            results = sim.run_simulation()

            elapsed = time.time() - start_time

            # Balance Paths
            fig_paths = go.Figure()
            paths = results.get("account_paths", [])
            for path in paths[:500]:  # limit for speed
                fig_paths.add_trace(go.Scatter(y=path, line=dict(width=1, color="rgba(100,150,255,0.15)"), showlegend=False))
            if paths:
                median_path = [sorted(year)[len(year)//2] for year in zip(*paths)]
                fig_paths.add_trace(go.Scatter(y=median_path, line=dict(width=3, color="navy"), name="Median"))
            fig_paths.update_layout(
                title=f"Portfolio Balance Paths ({n_sims:,} simulations)",
                xaxis_title="Year", yaxis_title="Value ($)",
                template="simple_white", height=520
            )

            # Histogram
            ending = results.get("ending_balances", [])
            fig_hist = go.Figure(data=[go.Histogram(x=ending, nbinsx=50)])
            fig_hist.update_layout(
                title="Ending Balance Distribution",
                xaxis_title="Final Value ($)", yaxis_title="Frequency",
                template="simple_white", height=520
            )

            # Metrics
            success = results.get("success_rate", 0)
            avoid_ruin = results.get("avoid_ruin_rate", 0)
            metrics = html.Div([
                html.H4("Simulation Results", style={"textAlign": "center"}),
                html.Table([
                    html.Tr([html.Td("Success Rate"), html.Td(f"{success:.1%}", style={"fontWeight": "bold", "color": "green" if success > 0.9 else "red"})]),
                    html.Tr([html.Td("Avoid Ruin Rate"), html.Td(f"{avoid_ruin:.1%}")]),
                    html.Tr([html.Td("Simulations"), html.Td(f"{n_sims:,}")]),
                    html.Tr([html.Td("Runtime"), html.Td(f"{elapsed:.2f}s")]),
                ], style={"margin": "auto", "fontSize": "16px"})
            ])

            debug = f"Simulation completed in {elapsed:.2f}s\n" \
                    f"Success: {success:.1%} | Avoid Ruin: {avoid_ruin:.1%}\n" \
                    f"Portfolio rows: {len(portfolio_rows)}\n" \
                    f"Debug log:\n" + "\n".join(getattr(sim, "debug_log", []))

            return fig_paths, fig_hist, metrics, debug

        except Exception as e:
            error = f"Simulation failed: {str(e)}"
            return go.Figure(), go.Figure(), html.Div(error, style={"color": "red"}), error
        
