# tax_planning.py
#
# Used for estimated taxes. Seperate tax_engine.py does final tyear end taxes correctly.
#
import copy
from typing import Tuple, Dict, Any
from utils.tax_utils import get_indexed_federal_constants 

def get_estimate_taxes(
    year: int,
    inflation_index: float,
    filing_status: TaxFilingStatus,
    state_of_residence: str,
    age1: int,
    age2: int,
    magi_two_years_ago: float,
    cash_needed: float,
    accounts: Dict,
    accounts_bal: Dict,
    withdrawal_order: list[str],
    non_portfolio_ordinary: float,  
    taxable_social_security: float, 
    itemized_deductions_amount: float = 0.0,
) -> Tuple[float, float, float]:
    """
    Wrapper to estimate the total annual tax (Federal, State, and IRMAA) for a 
    given planning scenario, including a hypothetical portfolio withdrawal or Roth conversion.

    This function is intended for tax *planning* (e.g., optimizing Roth conversions) 
    and combines all non-portfolio income with the estimated income generated by 
    'cash_needed' before running it through the robust tax engine.
    
    Args:
        year: The current simulation year.
        inflation_index: Current cumulative inflation factor for indexing constants.
        filing_status: TaxFilingStatus enum.
        state_of_residence: State abbreviation (e.g., 'VA').
        age1, age2: Ages of the individuals.
        magi_two_years_ago: MAGI from two years prior for IRMAA calculation.
        cash_needed: The amount of cash proposed to be withdrawn/converted from the portfolio.
        accounts: The dictionary of account definitions (basis, owner, etc.).
        accounts_bal: The current account balances.
        withdrawal_order: The strategic priority list for withdrawals/conversions.
        non_portfolio_ordinary: Sum of all other ordinary income (e.g., Pension, RMDs, 457b, Trust income).
        taxable_social_security: The portion of Social Security income that is taxable.
        itemized_deductions_amount: The amount of itemized deductions (0.0 if not itemizing).

    Returns:
        tuple[float, float, float]: (total_tax_owed, federal_tax, medicare_irmaa)
    """

    # 1. Estimate Portfolio Income (Ordinary and LTCG/QDiv)
    # This step simulates the tax character of the requested 'cash_needed'
    port_ord_inc, port_ltcg_qdiv = estimate_taxable_gap(
        cash_needed=cash_needed, 
        accounts=accounts, 
        accounts_bal=accounts_bal, 
        withdrawal_order=withdrawal_order,
        filing_status=filing_status
    )
    
    # 2. Aggregate All Income Sources for the Tax Engine

    # Total Taxable Ordinary Income (Line 2c on 1040, before Federal Deduction)
    # Includes: non-portfolio ordinary, taxable SS, and portfolio ordinary.
    total_taxable_ordinary = (
        non_portfolio_ordinary + 
        taxable_social_security + 
        port_ord_inc
    )

    # Total Preferential Income
    # NOTE: Since estimate_taxable_gap simplifies LTCG/QDiv into one lump sum 
    # (port_ltcg_qdiv), we must allocate it to one of the tax engine's parameters.
    # We allocate the entire amount to 'lt_cap_gains' for this planning estimate.
    total_lt_cap_gains = port_ltcg_qdiv
    total_qualified_dividends = 0.0 

    # Adjusted Gross Income (AGI)
    # AGI is the sum of all taxable income sources.
    AGI = (
        total_taxable_ordinary + 
        total_lt_cap_gains + 
        total_qualified_dividends
    )

    # 3. Call the Comprehensive Tax Engine for the Final Estimate
    # The main tax engine handles deductions, tax bracket application, and IRMAA.
    
    total_tax_owed, federal_tax, medicare_irmaa = calculate_taxes(
        year=year,
        inflation_index=inflation_index,
        filing_status=filing_status,
        state_of_residence=state_of_residence,
        age1=age1,
        age2=age2,
        magi_two_years_ago=magi_two_years_ago,
        AGI=AGI,
        taxable_ordinary=total_taxable_ordinary,
        lt_cap_gains=total_lt_cap_gains,
        qualified_dividends=total_qualified_dividends,
        social_security_income=taxable_social_security, 
        itemized_deductions_amount=itemized_deductions_amount,
    )

    return total_tax_owed, federal_tax, medicare_irmaa

def estimate_taxable_gap(
    cash_needed: float, 
    accounts: Dict, 
    accounts_bal: Dict, 
    withdrawal_order: list[str],
    filing_status: str
) -> Tuple[float, float]:
    """
    Estimates the ordinary income and LTCG income resulting from a portfolio 
    withdrawal of `cash_needed`, following the withdrawal priority.
    
    This function is a 'dry run' used for estimating taxes *before* a final withdrawal
    is executed or taxes are calculated.
    
    Args:
        cash_needed: The total cash amount to withdraw from the portfolio.
        accounts: The dictionary of account definitions (includes basis, owner, etc.).
        accounts_bal: The dictionary of current account balances.
        withdrawal_order: The strategic priority list (e.g., ["taxable", "traditional", ...]).
        
    Returns:
        tuple[float, float]: (ordinary_income, ltcg_income)
    """
    ordinary_income = 0.0
    ltcg_income = 0.0
    remaining = cash_needed
    
    # Use a copy of balances so the function doesn't modify the main simulation state
    est_tax_bal = accounts_bal.copy()

    for acct_type in withdrawal_order:
       # Find accounts matching this type (must match the logic in the simulator loop)
       target_accounts = [name for name, acct in accounts.items() if acct["tax"] == acct_type]
       
       for acct_name in target_accounts:
           acct = accounts[acct_name]
           if remaining <= 0:
               break

           acct_balance = est_tax_bal.get(acct_name, 0.0)
           if acct_balance <= 0:
               continue
               
           withdraw_amt = min(acct_balance, remaining)
           
           # --- Taxable Income Characterization ---
           if acct_type == "taxable":
               # Replicate the gain calculation logic exactly from the simulator's loop
               # This requires careful state management, relying on the basis stored in `accounts`.
               original_balance = acct.get("balance", acct_balance) 
               current_gain = max(0, original_balance - acct.get("basis", 0.0))
               
               if original_balance > 0 and current_gain > 0:
                   gain_percentage = current_gain / original_balance
                   realized_gains = withdraw_amt * gain_percentage
               else:
                   realized_gains = 0.0
                   
               # Split gains between ordinary and LTCG
               ordinary_part = realized_gains * acct.get("ordinary_pct", 0.1)
               ltcg_part = realized_gains - ordinary_part
               ordinary_income += ordinary_part
               ltcg_income += ltcg_part
               
           elif acct_type in ["inherited", "traditional", "def457b"]:
               # Tax-deferred draws are 100% ordinary income
               ordinary_income += withdraw_amt
               
           # ROTH and Trust Principle draws generate no income for tax purposes

           # Update estimated balance and remaining need
           est_tax_bal[acct_name] -= withdraw_amt
           remaining -= withdraw_amt

    return ordinary_income, ltcg_income

# --------------------------------------------------

def get_tax_planning_targets(
    year: int, 
    inflation_this_year: float, 
    roth_tax_bracket: str, 
    roth_irmaa_threshold: str, 
    filing_status: str
) -> Tuple[float, float]:
    """
    Determines the target tax bracket ceiling and IRMAA threshold based on 
    user-defined strategies for the current year.
    """
    
    # CORRECTED CALL: Use get_indexed_federal_constants to get the combined constants dictionary
    constants = get_indexed_federal_constants(year, inflation_this_year, filing_status)

    # Extract bracket ceilings from the constants dictionary (upper bound is index 1)
    fill_targets = {
        "fill_12_percent": constants["ord_dict"]["12_percent"][1],
        "fill_22_percent": constants["ord_dict"]["22_percent"][1],
        "fill_24_percent": constants["ord_dict"]["24_percent"][1],
        "fill_32_percent": constants["ord_dict"]["32_percent"][1],
    }
    
    # Extract IRMAA thresholds (returned as a 0-indexed list of 5 tiers)
    fill_thresholds = {
        "fill_IRMAA_1": constants["irmaa_thresholds"][0], # Tier 1 (Index 0)
        "fill_IRMAA_2": constants["irmaa_thresholds"][1], # Tier 2 (Index 1)
        "fill_IRMAA_3": constants["irmaa_thresholds"][2], # Tier 3 (Index 2)
        "fill_IRMAA_4": constants["irmaa_thresholds"][3], # Tier 4 (Index 3)
        "fill_IRMAA_5": constants["irmaa_thresholds"][4], # Tier 5 (Index 4)
    }
    
    # Apply tax strategy - fill a tax bracket
    tax_target = fill_targets.get(roth_tax_bracket, float('inf')) 

    # Apply IRMAA threshold 
    irmaa_target = fill_thresholds.get(roth_irmaa_threshold, float('inf'))
    
    # The actual planning target is the minimum of the two constraints
    return tax_target, irmaa_target
