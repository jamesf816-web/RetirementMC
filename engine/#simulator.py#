# engine.simulator.py

import numpy as np
import pandas as pd
import copy
import math
from typing import List, Dict, Tuple, Any

# --- Utilities and Models ---
from utils.xml_loader import DEFAULT_SETUP, DEFAULT_ACCOUNTS
from utils.currency import clean_percent
from models import PlannerInputs

# --- Configuration Imports
from config.expense_assumptions import (
    medicare_start_age,
    medicare_part_b_base_2026,
    medicare_supplement_annual,
    irmaa_brackets_start_year,
    mortgage_payoff_year,
    mortgage_monthly_until_payoff,
    property_tax_and_insurance,
    car_replacement_cycle,
    car_cost_today,
    car_inflation,
    home_repair_prob,
    home_repair_mean,
    home_repair_shape,
    lumpy_expenses
)
from config.market_assumptions import (
    initial_inflation_mu,
    initial_inflation_sigma,
    long_term_inflation_mu,
    long_term_inflation_sigma,
    years_to_revert,
    initial_equity_mu,
    initial_equity_sigma,
    long_term_equity_mu,
    long_term_equity_sigma,
    initial_bond_mu,
    initial_bond_sigma,
    long_term_bond_mu,
    long_term_bond_sigma,
    corr_matrix
)

from engine.rmd_tables import get_rmd_factor
from engine.roth_optimizer import optimal_roth_conversion

from engine.accounts_income import AccountsIncomeEngine # importing a class here
from engine.withdrawal_engine import WithdrawalEngine # importing a class here

from engine.tax_engine import calculate_taxes, get_effective_marginal_rates
from engine.market_generator import generate_returns, calculate_annual_inflation
        
class RetirementSimulator:
    """
    Runs Monte Carlo simulations for retirement planning, calculating taxes 
    and optimizing Roth conversions based on user inputs.
    """
    def __init__(self, inputs: PlannerInputs):

        # -----------------------
        # STEP 1: Initialize Inputs and Core Attributes
        # -----------------------
        self.inputs = inputs

        # Set all input fields as class attributes (e.g., self.nsims, self.current_year, etc.)
        for field, value in inputs.__dict__.items():
            setattr(self, field, value)

        # -----------------------
        # STEP 2: Normalize Accounts and Set Initial Balances
        # -----------------------
        # Must be called first to define 'self.initial_accounts' 
        self._normalize_accounts() 
        
        # Store initial balances for reference (Fix: use self.initial_accounts)
        self.initial_balances = self.initial_accounts 

        # -----------------------
        # STEP 3: Define Simulation Timeframe and Ages
        # -----------------------
        
        # Calculate current ages
        self.current_age_p1 = self.current_year - self.person1_birth_year - 1 # age at start of year
        # Use person1's year as fallback if person2_birth_year is None
        self.current_age_p2 = self.current_year - (self.person2_birth_year or self.person1_birth_year) - 1 # age at start of year

        # N = The length of the main simulation loop
        min_current_age = min(self.current_age_p1, self.current_age_p2)
        self.num_years = self.end_age - min_current_age
        
        # The full path length (N_full) includes two lookback years (Y-2, Y-1)
        self.n_full = self.num_years + 2 

        # Define simulation start parameters
        start_year = self.current_year - 2
        start_age_p1_path = self.current_age_p1 - 2
        start_age_p2_path = self.current_age_p2 - 2

        # Create the full arrays (Length n_full)
        self.years = np.arange(start_year, start_year + self.n_full).tolist()
        self.person1_ages = np.arange(start_age_p1_path, start_age_p1_path + self.n_full).tolist()
        self.person2_ages = np.arange(start_age_p2_path, start_age_p2_path + self.n_full).tolist()

        # Initialize random number generator for stoicastic home repair model
        self.rng = np.random.default_rng()
        
        # -----------------------
        # STEP 4: Initialize Path Storage
        # -----------------------
        # Initialization to None is appropriate since 'run_simulation' calculates the required size
        # and initializes them to numpy arrays of zeros.
        self.portfolio_paths = None
        self.conversion_paths = None
        self.plan_paths = None
        self.taxes_paths = None
        self.magi_paths = None
        self.base_spending_paths = None
        self.lumpy_spending_paths = None
        self.ssbenefit_paths = None
        self.portfolio_withdrawal_paths = None
        self.trust_income_paths = None
        self.rmd_paths = None
        self.def457b_income_paths = None
        self.pension_paths = None
        self.medicare_paths = None
        self.gifting_paths = None
        self.travel_paths = None

        self.account_paths = None

        self.debug_log = []

        # -----------------------
        # STEP 5: Initialize Accounts/Income Engine
        # -----------------------
        # This must happen after self.years, self.nsims, and ages are defined.
        self.accounts_income = AccountsIncomeEngine(
            years=self.years,
            num_sims=self.nsims,
            inputs=self.inputs,
            annual_inflation=None,
            ages_person1=self.person1_ages,
            ages_person2=self.person2_ages,
            return_trajectories=True
        )
        # Link the inputs object to the engine, which is necessary for the engine's methods 
        # (e.g., compute_rmds, compute_pension_income) to access parameters like birth years, etc.
        self.accounts_income.inputs = self.inputs
        

        # -----------------------
        # STEP 6: Instantiate a WithdrawalEngine in your simulator
        # -----------------------
        self.withdrawal_engine = WithdrawalEngine(
            inputs=self.inputs,
            accounts_metadata=self.initial_accounts  # metadata for account types, basis, ordinary_pct, etc.
        )

    # =========================================================================
    # 1. CORE SIMULATION RUNNER
    # =========================================================================
    def run_simulation(self):
        """Runs the Monte Carlo simulation over all paths."""
        num_paths = self.nsims
        num_years = self.num_years
        
        # Initialize storage arrays
        # n_full includes 2 prior years to initialize MAGI, portfolio data
        self.portfolio_paths = np.zeros((num_paths, self.n_full))
        self.conversion_paths = np.zeros((num_paths, self.n_full))
        self.plan_paths = np.zeros((num_paths, self.n_full))
        self.taxes_paths = np.zeros((num_paths, self.n_full))
        self.magi_paths = np.zeros((num_paths, self.n_full))
        self.base_spending_paths = np.zeros((num_paths, self.n_full))
        self.lumpy_spending_paths = np.zeros((num_paths, self.n_full))
        self.ssbenefit_paths = np.zeros((num_paths, self.n_full))
        self.portfolio_withdrawal_paths = np.zeros((num_paths, self.n_full))
        self.trust_income_paths = np.zeros((num_paths, self.n_full))
        self.rmd_paths = np.zeros((num_paths, self.n_full))
        self.def457b_income_paths = np.zeros((num_paths, self.n_full))
        self.pension_paths = np.zeros((num_paths, self.n_full))
        self.medicare_paths = np.zeros((num_paths, self.n_full))
        self.gifting_paths = np.zeros((num_paths, self.n_full))
        self.travel_paths = np.zeros((num_paths, self.n_full))

        # Account paths stores the *final* account balance structure for each path/year
        self.account_paths = [[None] * self.n_full for _ in range(num_paths)] 
        
        for path_index in range(num_paths):
            self._run_one_path(path_index)

        return self._summarize_results()


    # =========================================================================
    # 2. SINGLE PATH LOGIC
    # =========================================================================
    def _run_one_path(self, path_index: int):
        """Runs a single simulation path."""
        
        if path_index % 100 == 0:
            print(f">>> STARTING PATH {path_index} <<<")
        
        # Initialize state for this path
        current_accounts = copy.deepcopy(self.initial_accounts)

        annual_rmd_required = 0.0   # This year's total RMD (calculated once, drawn quarterly)
        final_ordinary_income_actual = 0.0
        total_taxes_final = 0.0
        spend_plan = 0.0
        
        # Initialize path-specific history arrays
        # MAGI history needs to be long enough to track 2 years prior for IRMAA (index offset)
        magi_path = [0.0] * 2 + [0.0] * self.num_years
        
        equity_q_path, bond_q_path = self._generate_market_path()

        inflation_path = self._generate_inflation_path()
        
        # --- PRE-SIMULATION SEED ---
        # Index 0 -> 2024 (initial_accounts)
        self.portfolio_paths[path_index, 0] = self._get_total_portfolio(self.initial_accounts)
        self.account_paths[path_index][0] = copy.deepcopy(self.initial_accounts)
        self.magi_paths[path_index, 0] = self.inputs.magi_1  # MAGI1

        # Index 1 -> 2025 (input accounts)
        self.portfolio_paths[path_index, 1] = self._get_total_portfolio(self.inputs.accounts)
        self.account_paths[path_index][1] = copy.deepcopy(self.inputs.accounts)
        self.magi_paths[path_index, 1] = self.inputs.magi_2  # MAGI2
        
        for i in range(self.num_years):
            year_index = i + 2 #start simulations at index 2
            current_year = self.current_year + i
            current_inflation_index = inflation_path[i]
            # Update ages
            current_age_person1 = self.current_age_p1 + i
            current_age_person2 = self.current_age_p2 + i if self.current_age_p2 is not None else Nonne

            # =========================================================================
            # --- STEP 1: CALCULATE ANNUAL INCOME AND RMDs ---
            # =========================================================================
            # AGI is calculated progressively
            AGI = 0.0
             
            # RMDs (Required Minimum Distributions)
            # Unpack the total RMD for AGI and the dictionary for quarterly withdrawals.
            annual_rmd_required, rmds_by_account_annual = self.accounts_income.compute_rmds(current_accounts, current_year)
            # Store the total annual RMD amount for the path
            self.rmd_paths[path_index, year_index] = annual_rmd_required
            AGI += annual_rmd_required
            
            # Pension/Def457b Income
            pension_income = self.accounts_income.compute_pension_income(current_year, current_inflation_index)
            def457b_income = self.accounts_income.compute_def457b_income(current_accounts, current_year)
            
            # Trust Income (New Addition)
            trust_income = self.accounts_income.compute_trust_income(
                current_accounts, 
                current_year, 
                current_inflation_index
            )
            
            # Add all fully taxable (Ordinary) income sources to AGI
            AGI += pension_income + def457b_income + trust_income
            
            # Save paths for tracking/reporting
            self.pension_paths[path_index, year_index] = pension_income
            self.def457b_income_paths[path_index, year_index] = def457b_income
            self.trust_income_paths[path_index, year_index] = trust_income
            
            # Social Security Income
            ss_benefit = self.accounts_income.compute_ss_benefit(current_year, current_inflation_index)
            ss_taxable = self.accounts_income.compute_taxable_ss(ss_benefit, AGI, self.inputs.filing_status) 
            AGI += ss_taxable # Taxable portion of SS contributes to AGI
            self.ssbenefit_paths[path_index, year_index] = ss_benefit # Save full benefit amount

            # ----------------------------
            # STEP 2 - PLAN ROTH conversions (do NOT mutate accounts here)
            # ----------------------------
            # Determine planned conversion amounts (use your existing optimizer)
            total_conversion_plan = 0.0

            # Person 2 planned conversion
            p2_trad_accts = [k for k, v in current_accounts.items()
                             if v.get("owner") == "person2" and v.get("tax") == "traditional"]
            p2_trad_bal = sum(current_accounts[k]["balance"] for k in p2_trad_accts)
            conv_p2 = 0.0
            if p2_trad_bal > 0:
                conv_p2 = optimal_roth_conversion(
                    year=current_year,
                    inflation_index=current_inflation_index,
                    filing_status=self.filing_status,
                    AGI_base=AGI,  # use the AGI *so far* as the base for planning
                    traditional_balance=p2_trad_bal,
                    roth_tax_bracket=self.roth_tax_bracket,
                    roth_irmaa_threshold=self.roth_irmaa_threshold
                )
            total_conversion_plan += conv_p2

            # Person 1 planned conversion
            p1_trad_accts = [k for k, v in current_accounts.items()
                             if v.get("owner") == "person1" and v.get("tax") == "traditional"]
            p1_trad_bal = sum(current_accounts[k]["balance"] for k in p1_trad_accts)
            conv_p1 = 0.0
            if p1_trad_bal > 0:
                conv_p1 = optimal_roth_conversion(
                    year=current_year,
                    inflation_index=current_inflation_index,
                    filing_status=self.filing_status,
                    AGI_base=AGI + conv_p2,  # plan P1 after P2 (AGI increases if P2 converts)
                    traditional_balance=p1_trad_bal,
                    roth_tax_bracket=self.roth_tax_bracket,
                    roth_irmaa_threshold=self.roth_irmaa_threshold
                )
            total_conversion_plan += conv_p1

            # Keep conv_p1/conv_p2 locally so we can execute them in Q4 later.
            planned_conv = {"person1": conv_p1, "person2": conv_p2}

            # =========================================================================
            # --- STEP 3: TAX CALCULATION ---
            # =========================================================================
            MAGI = AGI # Simplified: MAGI is often close to AGI, conversion is included.
            
            # Get MAGI from 2 years prior for IRMAA calculation (offset by 2)
            magi_two_years_ago = magi_path[year_index - 2] 
            
            total_taxes, federal_tax, medicare_irmaa = calculate_taxes(
                year=current_year,
                inflation_index=current_inflation_index,
                filing_status=self.filing_status,           
                state_of_residence=self.state_of_residence, 
                age1=current_age_person1,
                age2=current_age_person2,
                magi_two_years_ago=magi_two_years_ago,
                AGI=AGI,
                taxable_ordinary=AGI, # Simplified: Assumes AGI is the ordinary income base
                lt_cap_gains=0.0,     # Placeholder for Taxable account gains
                qualified_dividends=0.0, 
                social_security_income=ss_benefit,
            )

            # =========================================================================
            # --- STEP 4: DETERMINE ANNUAL WITHDRAWAL NEED ---
            # =========================================================================
            # This calculates the total cash DESIRED/REQUIRED from the portfolio for the year.

            (total_fixed_expenses, 
             annual_base_spending, 
             annual_lumpy_needs, 
             annual_home_repair,
             annual_travel_desired, 
             annual_gifting_desired) = self._calculate_annual_spending_needs(
                current_year, 
                current_inflation_index
            )

            # --- Define spend_plan from prior year portfolio balance ---
            prior_year_balance = self.portfolio_paths[path_index, year_index - 1]
            spend_plan = clean_percent(self.inputs.withdrawal_rate) * prior_year_balance
            self.plan_paths[path_index, year_index] = spend_plan

            # --- leftover for discretionary spending ---
            leftover_cash = max(0.0, spend_plan - annual_base_spending - annual_lumpy_needs)
            
            self.base_spending_paths[path_index, year_index] = annual_base_spending
            self.lumpy_spending_paths[path_index, year_index] = annual_lumpy_needs

            # Total desired cash for the year (Fixed Expenses + Desired Adjustable + Taxes)
            total_annual_withdrawal_needed = (
                total_fixed_expenses + 
                annual_travel_desired + 
                annual_gifting_desired + 
                total_taxes
            )

            # Cash from non-portfolio sources (Pension, SS, Def457b)
            total_annual_cash_in = (
                pension_income + 
                def457b_income + 
                ss_benefit
            )

            # -------------------------------
            # Discretionary Travel
            # -------------------------------
            leftover_cash = max(0, spend_plan - (annual_base_spending + annual_lumpy_needs + total_taxes_final))

            # Travel target: full until 2035, then half, inflated
            target_travel = annual_travel_desired if current_year <= 2035 else annual_travel_desired / 2
            target_travel *= current_inflation_index
            proposed_travel = min(target_travel, leftover_cash)

            # Estimate ordinary/LTCG portion for tax basis using withdrawal_engine simulation
            tax_sim_bal = copy.deepcopy(current_accounts)
            simulate_only = True
            res = self.withdrawal_engine._withdraw_from_hierarchy(
                cash_needed=proposed_travel,
                accounts_bal=tax_sim_bal,
                simulate_only=simulate_only
            )
            travel_ordinary = res.get("ordinary_inc", 0.0)
            travel_ltcg = res.get("ltcg_inc", 0.0)

            # Compute MAGI including Social Security and prior ordinary/LTCG income
            MAGI_proposed_travel = final_ordinary_income_actual + travel_ordinary + travel_ltcg + ss_benefit
            # Use tax engine to get effective marginal rates for this income
            federal_rate, state_rate = get_effective_marginal_rates(
                year=current_year,
                income=MAGI_proposed_travel,
                filing_status=self.filing_status,
                state_of_residence=self.state_of_residence,
                age1=current_age_person1,
                age2=current_age_person2,
                inflation_index=current_inflation_index
            )
            total_rate = 1 + federal_rate + state_rate

            # Reduce proposed travel if MAGI exceeds your target threshold (if any)
            # If you have a target MAGI for IRMAA/fill strategy, define it here:
            MAGI_limit = float('inf')  # or a specific target if needed
            if MAGI_proposed_travel > MAGI_limit:
                over = MAGI_proposed_travel - MAGI_limit
                proposed_travel -= over / total_rate
  
            # Round to nearest $1,000 and ensure non-negative
            actual_travel = max(0, math.ceil(proposed_travel / 1000) * 1000)
            self.travel_paths[path_index, year_index] = actual_travel

            # Update the net portfolio draw for this year
            annual_portfolio_draw_needed = max(0.0, total_annual_withdrawal_needed - total_annual_cash_in)
            self.portfolio_withdrawal_paths[path_index, year_index] = annual_portfolio_draw_needed

            # =========================================================================
            # --- STEP 5: QUARTERLY WITHDRAWAL AND INVESTMENT RETURNS ---
            # =========================================================================

            # Annual amounts (these were computed above)
            quarterly_rmd_draw = annual_rmd_required / 4.0
            quarterly_def457b_draw = def457b_income / 4.0
            quarterly_trust_income_draw = trust_income / 4.0
            quarterly_portfolio_draw_needed = annual_portfolio_draw_needed / 4.0

            # Slice the 4 quarterly returns
            eq_q_returns   = equity_q_path[i * 4 : (i + 1) * 4]
            bond_q_returns = bond_q_path[i * 4 : (i + 1) * 4]

            # Track realized tax character for this year's income accounting
            final_ordinary_income_actual = 0.0
            final_ltcg_income_actual = 0.0

            for q in range(4):
                # 1. Original accounts
                current_accounts = current_accounts  # your baseline

                # 2. Deepcopy for tax simulation (already in your code)
                tax_sim_bal = copy.deepcopy(current_accounts)

                # 3. Deepcopy for actual ROTH conversions (safe isolation)
                conversion_accounts = copy.deepcopy(current_accounts)
            
                # ---------------------------------------------------------------------
                # 1) MANDATORY QUARTERLY DRAWS (RMDs & Trust Income) and 457b Income
                # ---------------------------------------------------------------------
                
                # We no longer rely on a total RMD target, but withdraw the 1/4 RMD
                # from each specific account, as required by law.
                
                # 1a) RMD Draw: Withdraw the required amount from each specific account
                for acct_name, annual_rmd_amount in rmds_by_account_annual.items():
                    # Look up the account state
                    acct = current_accounts.get(acct_name)
                    
                    if acct and acct.get("balance", 0.0) > 0:
                        
                        quarterly_rmd = annual_rmd_amount / 4.0
                        
                        # Draw amount is limited by the current balance
                        draw_amount = min(quarterly_rmd, acct["balance"])
                        
                        acct["balance"] -= draw_amount
                        final_ordinary_income_actual += draw_amount # RMD is ordinary income

                # 1b) Trust Income Draw: Withdraw the quarterly portion from Trust accounts
                quarterly_trust_income_draw = trust_income / 4.0
                trust_draw_remaining_q = quarterly_trust_income_draw

                # Iterate over accounts, prioritizing drawing the required trust income
                # from any available Trust account until the quarterly requirement is met.
                for acct_name, acct in current_accounts.items():
                    if acct.get("tax") == "trust" and acct.get("balance", 0.0) > 0 and trust_draw_remaining_q > 0:
                        
                        # Draw up to the remaining required trust income, capped by balance
                        draw_amount = min(trust_draw_remaining_q, acct["balance"])
                        
                        acct["balance"] -= draw_amount
                        trust_draw_remaining_q -= draw_amount
                        final_ordinary_income_actual += draw_amount # Trust Income is ordinary income
                        
                        if trust_draw_remaining_q <= 0:
                            break # Trust income draw satisfied for the quarter

                # 1c) Deferred 457b Income Draw: Withdraw the quarterly portion from 457b accounts
                quarterly_def457b_income_draw = def457b_income / 4.0
                def457b_draw_remaining_q = quarterly_def457b_income_draw

                for acct_name, acct in current_accounts.items():
                    if acct.get("tax") == "def457b" and acct.get("balance", 0.0) > 0 and def457b_draw_remaining_q > 0:
                        
                        draw_amount = min(def457b_draw_remaining_q, acct["balance"])
                        
                        acct["balance"] -= draw_amount
                        def457b_draw_remaining_q -= draw_amount
                        final_ordinary_income_actual += draw_amount # Trust Income is ordinary income
                        
                        if def457b_draw_remaining_q <= 0:
                            break # def457b income draw satisfied for the quarter

                # ---------------------------------------------------------------------
                # 2) RESIDUAL PORTFOLIO WITHDRAWAL (For remaining spending needs)
                # ---------------------------------------------------------------------
                
                # annual_portfolio_draw_needed was calculated in STEP 4 (Total needs - Non-portfolio income)
                # It is the amount that MUST be withdrawn from IRA/Roth/Taxable/Trust (beyond RMD/Trust draw)
                quarterly_portfolio_draw_remaining = annual_portfolio_draw_needed / 4.0

                simulate_only = False #doing actual portfolio draws now
                quarterly_portfolio_draw_remaining = quarterly_portfolio_draw_needed
                if quarterly_portfolio_draw_remaining > 0:
                    withdrawal_result = self.accounts_income._withdraw_from_hierarchy(
                        cash_needed=quarterly_portfolio_draw_remaining,
                        accounts_bal=current_accounts,
                        simulate_only=simulate_only,
                    )
                    final_ordinary_income_actual += withdrawal_result.get("ordinary_inc", 0.0)
                    final_ltcg_income_actual += withdrawal_result.get("ltcg_inc", 0.0)


                # ---------------------------------------------------------------------
                # 2) In Q4 do ROTH conversions and Gifting
                # ---------------------------------------------------------------------
                if q == 3:
                    # Execute conversions in Q4 only
                    running_total = 0.0
                    # Person 2
                    conv = planned_conv.get("person2", 0.0)
                    if conv > 0:
                        # pro-rata across person's trad accounts
                        p2_trads = [n for n, a in current_accounts.items() if a.get("owner") == "person2" and a.get("tax") == "traditional" and a.get("balance",0) > 0]
                        p2_total = sum(current_accounts[n]["balance"] for n in p2_trads)
                        # choose a Roth target (existing roth)
                        p2_roths = [n for n,a in current_accounts.items() if a.get("owner") == "person2" and a.get("tax") == "roth"]
                        if p2_roths and p2_total > 0:
                            roth_target = p2_roths[0]
                            remaining = conv
                            for n in p2_trads:
                                if remaining <= 0:
                                    break
                                available = current_accounts[n]["balance"]
                                take = min(available, conv * (available / p2_total))
                                # safety clamp
                                take = min(take, remaining, current_accounts[n]["balance"])
                                current_accounts[n]["balance"] -= take
                                current_accounts[roth_target]["balance"] += take
                                final_ordinary_income_actual += take   # conversions = ordinary income realized in Q4
                                remaining -= take
                                running_total += take

                    # Person 1 (same pattern)
                    conv = planned_conv.get("person1", 0.0)
                    if conv > 0:
                        p1_trads = [n for n, a in current_accounts.items() if a.get("owner") == "person1" and a.get("tax") == "traditional" and a.get("balance",0) > 0]
                        p1_total = sum(current_accounts[n]["balance"] for n in p1_trads)
                        p1_roths = [n for n,a in current_accounts.items() if a.get("owner") == "person1" and a.get("tax") == "roth"]
                        if p1_roths and p1_total > 0:
                            roth_target = p1_roths[0]
                            remaining = conv
                            for n in p1_trads:
                                if remaining <= 0:
                                    break
                                available = current_accounts[n]["balance"]
                                take = min(available, conv * (available / p1_total))
                                take = min(take, remaining, current_accounts[n]["balance"])
                                current_accounts[n]["balance"] -= take
                                current_accounts[roth_target]["balance"] += take
                                final_ordinary_income_actual += take
                                remaining -= take
                                running_total += take
                                
                    # after both person conv executions
                    self.conversion_paths[path_index, year_index] = running_total

                # -------------------------------
                # 2) Gifting
                # -------------------------------
                leftover_for_gifting = max(
                    0,
                    spend_plan - (annual_base_spending + annual_lumpy_needs + actual_travel + total_taxes_final)
                )
                target_gifting = annual_gifting_desired * current_inflation_index
                proposed_gifting = min(leftover_for_gifting, target_gifting)

                # Estimate ordinary/LTCG portion for tax basis using simulation
                simulate_only = True # simulating draws first
                tax_sim_bal = copy.deepcopy(current_accounts)
                res = self.withdrawal_engine._withdraw_from_hierarchy(
                    cash_needed=proposed_gifting,
                    accounts_bal=tax_sim_bal,
                    simulate_only=simulate_only
                )
                ordinary_income = res.get("ordinary_inc", 0.0)
                ltcg_income = res.get("ltcg_inc", 0.0)

                taxable_gifting = final_ordinary_income_actual + ordinary_income + ltcg_income

                # Use tax engine to get effective marginal rates for this income
                federal_rate, state_rate = get_effective_marginal_rates(
                    year=current_year,
                    income=taxable_gifting,
                    filing_status=self.filing_status,
                    state_of_residence=self.state_of_residence,
                    age1=current_age_person1,
                    age2=current_age_person2,
                    inflation_index=current_inflation_index
                )
                total_rate = 1 + federal_rate + state_rate  # scale factor for reducing withdrawal

                # Optionally, define a target MAGI to limit gifting for IRMAA/fill purposes
                MAGI_limit = float('inf')  # replace with a specific target if needed
                if taxable_gifting > MAGI_limit:
                    over = taxable_gifting - MAGI_limit
                    proposed_gifting -= over / total_rate

                # Round to nearest $1,000
                actual_gifting = max(0, math.ceil(proposed_gifting / 1000) * 1000)
                self.gifting_paths[path_index, year_index] = actual_gifting

                # Execute withdrawal from portfolio
                simulate_only = False # doing actual portfolio draw
                if actual_gifting > 0:
                    withdrawal_result = self.withdrawal_engine._withdraw_from_hierarchy(
                        cash_needed=actual_gifting,
                        accounts_bal=current_accounts,
                        simulate_only=simulate_only
                    )
                    final_ordinary_income_actual += withdrawal_result.get("ordinary_inc", 0.0)
                    final_ltcg_income_actual += withdrawal_result.get("ltcg_inc", 0.0)

                # ---------------------------------------------------------------------
                # 3) APPLY QUARTERLY RETURNS
                # ---------------------------------------------------------------------
                eq_r = eq_q_returns[q]
                bond_r = bond_q_returns[q]

                for acct_name, acct in current_accounts.items():

                    bal = acct.get("balance", 0.0)
                    if bal <= 0:
                        # Skip negative/empty accounts — prevents pathological return explosions
                        acct["balance"] = 0.0
                        continue

                    # Guaranteed normalized in Stage 1
                    eq_pct = acct["equity_pct"]
                    bond_pct = acct["bond_pct"]

                    blended_q_ret = eq_pct * eq_r + bond_pct * bond_r

                    # Apply return
                    new_bal = bal * (1 + blended_q_ret)
                    acct["balance"] = new_bal

                    # Basis tracking for taxable accounts only
                    if acct.get("tax") == "taxable":
                        basis = acct.get("basis", 0.0)
                        acct["basis"] = basis + (basis * blended_q_ret)

            # =========================================================================
            # --- STEP 6: POST-QUARTERLY CLEANUP AND SAVE DATA ---
            # =========================================================================
            # final_ordinary_income_actual and final_ltcg_income_actual include:
            #   - withdrawals that were ordinary income
            #   - realized LTCG
            #   - ROTH conversions we added in Q4 above (as ordinary income)

            final_MAGI = final_ordinary_income_actual + final_ltcg_income_actual + ss_benefit
            self.magi_paths[path_index, year_index] = final_MAGI

            total_taxes_final, federal_tax_final, medicare_irmaa_final = calculate_taxes(
                year=current_year,
                inflation_index=current_inflation_index,
                filing_status=self.filing_status,
                state_of_residence=self.state_of_residence,
                age1=current_age_person1,
                age2=current_age_person2,
                magi_two_years_ago=magi_path[year_index - 2],
                AGI=final_ordinary_income_actual + final_ltcg_income_actual,
                taxable_ordinary=final_ordinary_income_actual,
                lt_cap_gains=final_ltcg_income_actual,
                qualified_dividends=0.0,
                social_security_income=ss_benefit,
            )
            self.taxes_paths[path_index, year_index] = total_taxes_final
            self.medicare_paths[path_index, year_index] = medicare_irmaa_final

            # Final Portfolio Balance
            self.portfolio_paths[path_index, year_index] = self._get_total_portfolio(current_accounts)
            
            # Save the final account state for the year
            self.account_paths[path_index][year_index] = copy.deepcopy(current_accounts)

            self.travel_paths[path_index, year_index] = annual_travel_desired
            self.gifting_paths[path_index, year_index] = annual_gifting_desired

            # After all conversions, update the main accounts
            current_accounts = conversion_accounts

    # =========================================================================
    # 3. UTILITY FUNCTIONS — Modular Wiring Only
    # =========================================================================

    def _normalize_accounts(self):
        """Ensure account dicts have required fields and canonical numeric types.

        - Accept either 'equity'/'bond' or 'equity_pct'/'bond_pct' from XML.
        - Convert numeric strings to floats.
        - Ensure balances/basis are floats (default 0.0).
        - Compute equity_pct as equity / (equity + bond) if both present.
        """
        import numbers

        # Make a defensive deep copy of the input accounts so we can mutate safely
        self.initial_accounts = copy.deepcopy(self.inputs.accounts)

        for acct_name, acct in self.initial_accounts.items():
            # --- normalize numeric fields ---
            # Accept strings coming from XML and coerce to float safely.
            def _to_float(val, default=0.0):
                if val is None:
                    return default
                if isinstance(val, numbers.Number):
                    return float(val)
                try:
                    return float(str(val))
                except Exception:
                    return default

            acct['balance'] = _to_float(acct.get('balance', 0.0), 0.0)
            acct['basis']   = _to_float(acct.get('basis', 0.0), 0.0)

            # Tax/owner defaults
            acct['tax'] = acct.get('tax') or 'traditional'
            acct['owner'] = acct.get('owner') or 'person1'
            acct.setdefault('income', 0.0)
            acct.setdefault('ordinary_pct', 0.1)

            # --- normalize asset mix ---
            # Accept either 'equity'/'bond' or 'equity_pct'/'bond_pct'
            raw_equity = acct.get('equity', acct.get('equity_pct', None))
            raw_bond   = acct.get('bond', acct.get('bond_pct', None))

            # Coerce to floats where present
            equity = _to_float(raw_equity, None)
            bond   = _to_float(raw_bond, None)

            # If both are None => fallback default mix (70/30)
            if equity is None and bond is None:
                equity_pct = 0.70
            else:
                # If only one side present, assume the other is the complement (if sensible)
                if equity is None:
                    # bond given -> equity = 1 - bond
                    bond = min(max(bond, 0.0), 1.0)
                    equity = 1.0 - bond
                elif bond is None:
                    equity = min(max(equity, 0.0), 1.0)
                    bond = 1.0 - equity

                s = equity + bond
                if s <= 0:
                    equity_pct = 0.70
                else:
                    equity_pct = equity / s

            acct['equity_pct'] = float(equity_pct)
            acct['bond_pct'] = float(1.0 - equity_pct)

        # End _normalize_accounts

    def _get_total_portfolio(self, accounts: Dict) -> float:
        """Return total portfolio balance as sum of numeric balances (no magic pennies)."""
        total = 0.0
        for acct in accounts.values():
            bal = acct.get('balance', 0.0)
            try:
                total += float(bal) if bal is not None else 0.0
            except Exception:
                # defensive fallback if someone passed a weird type
                total += 0.0
        return total


    def _generate_market_path(self) -> Tuple[List[float], List[float]]:
        """
        One path of *quarterly* portfolio returns using market_generator.
        Returns separate lists for Equity and Bond quarterly returns.
        """
        from config.market_assumptions import (
            corr_matrix, initial_equity_mu, long_term_equity_mu,
            initial_equity_sigma, long_term_equity_sigma, initial_bond_mu, 
            long_term_bond_mu, initial_bond_sigma, long_term_bond_sigma, 
            initial_inflation_mu, long_term_inflation_mu, 
            initial_inflation_sigma, long_term_inflation_sigma
        )
        
        eq_q, bond_q, _ = generate_returns(
            n_full=self.num_years, 
            nsims=1,
            corr_matrix=corr_matrix,
            initial_equity_mu=initial_equity_mu,
            long_term_equity_mu=long_term_equity_mu,
            initial_equity_sigma=initial_equity_sigma,
            long_term_equity_sigma=long_term_equity_sigma,
            initial_bond_mu=initial_bond_mu,
            long_term_bond_mu=long_term_bond_mu,
            initial_bond_sigma=initial_bond_sigma,
            long_term_bond_sigma=long_term_bond_sigma,
            initial_inflation_mu=initial_inflation_mu,
            long_term_inflation_mu=long_term_inflation_mu,
            initial_inflation_sigma=initial_inflation_sigma,
            long_term_inflation_sigma=long_term_inflation_sigma,
        )
        
        # Explicitly return a tuple of two lists, ensuring two items are unpacked.
        # [0, :] flattens the (1, N) array into a 1D array before converting to a list.
        return (eq_q[0, :].tolist(), bond_q[0, :].tolist())
    
    def _generate_inflation_path(self) -> List[float]:
        """One path of cumulative inflation index."""
        _, _, infl_q = generate_returns(
            n_full=self.num_years,
            nsims=1,
            corr_matrix=corr_matrix,
            initial_equity_mu=initial_equity_mu,
            long_term_equity_mu=long_term_equity_mu,
            initial_equity_sigma=initial_equity_sigma,
            long_term_equity_sigma=long_term_equity_sigma,
            initial_bond_mu=initial_bond_mu,
            long_term_bond_mu=long_term_bond_mu,
            initial_bond_sigma=initial_bond_sigma,
            long_term_bond_sigma=long_term_bond_sigma,
            initial_inflation_mu=initial_inflation_mu,
            long_term_inflation_mu=long_term_inflation_mu,
            initial_inflation_sigma=initial_inflation_sigma,
            long_term_inflation_sigma=long_term_inflation_sigma,
        )
        cumulative = [1.0]
        for y in range(self.num_years):
            q_rates = infl_q[0, y*4:(y+1)*4]
            ann_rate, _ = calculate_annual_inflation(q_rates, cumulative[-1])
            cumulative.append(cumulative[-1] * (1 + ann_rate))
        return cumulative[1:]  # drop year 0 = 1.0

    def _calculate_annual_spending_needs(self, 
        current_year: int, 
        inflation_index: float) -> Tuple[float, float, float, float, float, float]:
        """
        Calculates total annual expenses (fixed and adjustable).
        
        Returns: 
            (total_fixed_expenses, annual_base_spending, 
             annual_lumpy_needs, annual_home_repair, 
             annual_travel_desired, annual_gifting_desired)
        """
        
        from config.expense_assumptions import (
            mortgage_payoff_year, mortgage_monthly_until_payoff,
            property_tax_and_insurance, car_replacement_cycle,
            car_cost_today, lumpy_expenses,
            home_repair_prob, home_repair_mean, home_repair_shape,
        )
        
        # 1. Base Spending (Inflation-Adjusted)
        annual_base_spending = self.base_annual_spending * inflation_index
        
        # 2. Housing/Fixed Expenses (Mortgage is fixed, P&T is inflation-adjusted)
        mortgage_expense = 0.0
        if current_year <= mortgage_payoff_year:
            mortgage_expense = mortgage_monthly_until_payoff 
            
        property_and_tax = property_tax_and_insurance * inflation_index 

        # 3. Lumpy Expenses (Check against configuration list)
        annual_lumpy_needs = 0.0
        for item in lumpy_expenses:
            if item.get("year") == current_year:
                annual_lumpy_needs += item.get("amount", 0.0) * inflation_index 
                
        # 4. Car Replacement (Every 'car_replacement_cycle' years, inflated)
        car_expense = 0.0
        years_since_start = current_year - self.current_year
        if years_since_start % car_replacement_cycle == 0 and years_since_start >= 0:
            car_expense = car_cost_today * inflation_index
            
        # 5. Stochastic Home Repair (Restored Logic)
        annual_home_repair = 0.0
        if self.rng.random() < home_repair_prob:
            # Draw from log-normal distribution (requires self.rng to be a seeded generator)
            mu_log = np.log(home_repair_mean) - (home_repair_shape ** 2) / 2
            annual_home_repair = self.rng.lognormal(mu_log, home_repair_shape) * inflation_index
        
        # TOTAL FIXED EXPENSES (Required draw from portfolio/cash flow)
        total_fixed_expenses = (
            annual_base_spending +
            mortgage_expense +
            property_and_tax +
            annual_lumpy_needs +
            car_expense +
            annual_home_repair
        )
        
        # 6. Discretionary Spending (Dynamically Adjustable to manage tax/IRMAA)
        # These are the DESIRED amounts, which may be cut by the planner (Step 2/3)
        annual_travel_desired = self.travel * inflation_index
        annual_gifting_desired = self.gifting * inflation_index
        
        return (
            total_fixed_expenses, 
            annual_base_spending, 
            annual_lumpy_needs, 
            annual_home_repair,
            annual_travel_desired, 
            annual_gifting_desired
        )

    # =========================================================================
    # 4. RESULTS SUMMARIZER
    # =========================================================================
    def _summarize_results(self) -> Dict[str, Any]:
        """
        Summarizes the final state of all simulation paths, performing required 
        data transposition and ensuring all paths are defensive arrays.
        """
        import numpy as np
        
        # If simulation paths were not successfully generated, return defensive empty results
        if self.portfolio_paths is None or self.portfolio_paths.size == 0:
             # Defensive returns for all paths to prevent AxisError in plotting
             return {
                "success_rate": 0.0,
                "avoid_ruin_rate": 0.0,
                "median_final": 0.0,
                "p10_final": 0.0,
                "portfolio_paths": np.array([]),
                "account_paths": {},
                "conversion_paths": np.array([]),
                "taxes_paths": np.array([]),
                "magi_paths": np.array([]),
                "trust_income_paths": np.array([]),
                "ssbenefit_paths": np.array([]),
                "portfolio_withdrawal_paths": np.array([]),
                "rmd_paths": np.array([]),
                "def457b_income_paths": np.array([]),
                "pension_paths": np.array([]),
                "medicare_paths": np.array([]),
                "travel_paths": np.array([]),
                "gifting_paths": np.array([]),
                "base_spending_paths": np.array([]),
                "lumpy_spending_paths": np.array([]),
                "plan_paths": np.array([]),
             }

        success = self.inputs.success_threshold
        avoid_ruin = self.inputs.avoid_ruin_threshold
        portfolio_end = self.portfolio_paths[:, -1]
        
        success_rate = np.mean(portfolio_end > success) * 100
        minimum_annual_balance = np.min(self.portfolio_paths, axis=1)
        avoid_ruin_rate = np.mean(minimum_annual_balance > avoid_ruin) * 100
        
        # --- START FIX: Transpose account_paths and filter to XML-defined names ---
        num_paths, num_years = self.portfolio_paths.shape

        account_paths_list = getattr(self, 'account_paths', [])
        
        # The set of valid names are those defined in the user's XML inputs.
        xml_account_names = set(self.inputs.accounts.keys())

        # 1. Determine all unique account names *actually* present in the results
        account_names_in_results = set()
        for path in account_paths_list:
            for account_state in path:
                if account_state:
                    account_names_in_results.update(account_state.keys())

        # Filter: Only transpose accounts that were defined in the XML (e.g., keep 'Roth_IRA', drop 'Roth')
        names_to_transpose = xml_account_names.intersection(account_names_in_results)

        # 2. Initialize the transposed structure
        transposed_account_paths = {}
        for name in names_to_transpose:
            transposed_account_paths[name] = np.zeros((num_paths, num_years))

        # 3. Fill the transposed structure
        for i in range(num_paths):
            for j in range(num_years):
                account_state = account_paths_list[i][j]
                if account_state is not None:
                    for name in names_to_transpose:
                        # Extract the balance, defaulting to 0.0
                        # Balance is nested: acct_state['AccountName']['balance']
                        balance = account_state.get(name, {}).get('balance', 0.0)
                        transposed_account_paths[name][i, j] = balance
        # --- END Transposition and Filtering FIX ---

        result = {
            "success_rate": success_rate,
            "avoid_ruin_rate": avoid_ruin_rate,
            "median_final": np.median(portfolio_end),
            "p10_final": np.percentile(portfolio_end, 10),
            
            # --- PATHS ---
            "portfolio_paths": self.portfolio_paths, 
            "account_paths": transposed_account_paths, # <-- THE CORRECTED, TRANSPOSED, AND FILTERED DICTIONARY
            
            # All other paths are retrieved and defaulted to an empty array to prevent AxisError
            "conversion_paths": getattr(self, 'conversion_paths', np.array([])),
            "taxes_paths": getattr(self, 'taxes_paths', np.array([])),
            "magi_paths": getattr(self, 'magi_paths', np.array([])),
            "trust_income_paths": getattr(self, 'trust_income_paths', np.array([])),
            "ssbenefit_paths": getattr(self, 'ssbenefit_paths', np.array([])),
            "portfolio_withdrawal_paths": getattr(self, 'portfolio_withdrawal_paths', np.array([])),
            "rmd_paths": getattr(self, 'rmd_paths', np.array([])),
            "def457b_income_paths": getattr(self, 'def457b_income_paths', np.array([])),
            "pension_paths": getattr(self, 'pension_paths', np.array([])),
            "medicare_paths": getattr(self, 'medicare_paths', np.array([])),
            "travel_paths": getattr(self, 'travel_paths', np.array([])),
            "gifting_paths": getattr(self, 'gifting_paths', np.array([])),
            "base_spending_paths": getattr(self, 'base_spending_paths', np.array([])),
            "lumpy_spending_paths": getattr(self, 'lumpy_spending_paths', np.array([])),
            "plan_paths": getattr(self, 'plan_paths', np.array([])),
        }
        return result
